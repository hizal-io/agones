// Copyright 2022 Google LLC All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code was autogenerated. Do not edit directly.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package agones.dev.agones.pkg.apis.agones.v1;

import "k8s.io/api/apps/v1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "agones.dev/agones/pkg/apis/agones/v1";

// AggregatedCounterStatus stores total Counter tracking values
message AggregatedCounterStatus {
  optional int64 count = 1;

  optional int64 capacity = 2;
}

// AggregatedListStatus stores total List tracking values
message AggregatedListStatus {
  optional int64 count = 1;

  optional int64 capacity = 2;
}

// AggregatedPlayerStatus stores total player tracking values
message AggregatedPlayerStatus {
  optional int64 count = 1;

  optional int64 capacity = 2;
}

// AllocationOverflow specifies what labels and/or annotations to apply on Allocated GameServers
// if the desired number of the underlying `GameServerSet` drops below the number of Allocated GameServers
// attached to it.
message AllocationOverflow {
  // Labels to be applied to the `GameServer`
  // +optional
  map<string, string> labels = 1;

  // Annotations to be applied to the `GameServer`
  // +optional
  map<string, string> annotations = 2;
}

// CounterStatus stores the current counter values
message CounterStatus {
  optional int64 count = 1;

  optional int64 capacity = 2;
}

// Eviction specifies the eviction tolerance of the GameServer
message Eviction {
  // Game server supports termination via SIGTERM:
  // - Always: Allow eviction for both Cluster Autoscaler and node drain for upgrades
  // - OnUpgrade: Allow eviction for upgrades alone
  // - Never (default): Pod should run to completion
  optional string safe = 1;
}

// Fleet is the data structure for a Fleet resource
message Fleet {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional FleetSpec spec = 2;

  optional FleetStatus status = 3;
}

// FleetList is a list of Fleet resources
message FleetList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Fleet items = 2;
}

// FleetSpec is the spec for a Fleet
message FleetSpec {
  // Replicas are the number of GameServers that should be in this set. Defaults to 0.
  optional int32 replicas = 1;

  // [Stage: Alpha]
  // [FeatureFlag:FleetAllocationOverflow]
  // Labels and/or Annotations to apply to overflowing GameServers when the number of Allocated GameServers is more
  // than the desired replicas on the underlying `GameServerSet`
  // +optional
  optional AllocationOverflow allocationOverflow = 5;

  // Deployment strategy
  optional k8s.io.api.apps.v1.DeploymentStrategy strategy = 2;

  // Scheduling strategy. Defaults to "Packed".
  optional string scheduling = 3;

  // Template the GameServer template to apply for this Fleet
  optional GameServerTemplateSpec template = 4;
}

// FleetStatus is the status of a Fleet
message FleetStatus {
  // Replicas the total number of current GameServer replicas
  optional int32 replicas = 1;

  // ReadyReplicas are the number of Ready GameServer replicas
  optional int32 readyReplicas = 2;

  // ReservedReplicas are the total number of Reserved GameServer replicas in this fleet.
  // Reserved instances won't be deleted on scale down, but won't cause an autoscaler to scale up.
  optional int32 reservedReplicas = 3;

  // AllocatedReplicas are the number of Allocated GameServer replicas
  optional int32 allocatedReplicas = 4;

  // [Stage:Alpha]
  // [FeatureFlag:PlayerTracking]
  // Players are the current total player capacity and count for this Fleet
  // +optional
  optional AggregatedPlayerStatus players = 5;

  // (Alpha, CountsAndLists feature flag) Counters provides aggregated Counter capacity and Counter
  // count for this Fleet.
  // +optional
  map<string, AggregatedCounterStatus> counters = 6;

  // (Alpha, CountsAndLists feature flag) Lists provides aggregated List capacityv and List values
  // for this Fleet.
  // +optional
  map<string, AggregatedListStatus> lists = 7;
}

// GameServer is the data structure for a GameServer resource.
// It is worth noting that while there is a `GameServerStatus` Status entry for the `GameServer`, it is not
// defined as a subresource - unlike `Fleet` and other Agones resources.
// This is so that we can retain the ability to change multiple aspects of a `GameServer` in a single atomic operation,
// which is particularly useful for operations such as allocation.
message GameServer {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional GameServerSpec spec = 2;

  optional GameServerStatus status = 3;
}

// GameServerList is a list of GameServer resources
message GameServerList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated GameServer items = 2;
}

// GameServerPort defines a set of Ports that
// are to be exposed via the GameServer
message GameServerPort {
  // Name is the descriptive name of the port
  optional string name = 1;

  // PortPolicy defines the policy for how the HostPort is populated.
  // Dynamic port will allocate a HostPort within the selected MIN_PORT and MAX_PORT range passed to the controller
  // at installation time.
  // When `Static` portPolicy is specified, `HostPort` is required, to specify the port that game clients will
  // connect to
  optional string portPolicy = 2;

  // Container is the name of the container on which to open the port. Defaults to the game server container.
  // +optional
  optional string container = 3;

  // ContainerPort is the port that is being opened on the specified container's process
  optional int32 containerPort = 4;

  // HostPort the port exposed on the host for clients to connect to
  optional int32 hostPort = 5;

  // Protocol is the network protocol being used. Defaults to UDP. TCP and TCPUDP are other options.
  optional string protocol = 6;
}

// GameServerSet is the data structure for a set of GameServers.
// This matches philosophically with the relationship between
// Deployments and ReplicaSets
message GameServerSet {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional GameServerSetSpec spec = 2;

  optional GameServerSetStatus status = 3;
}

// GameServerSetList is a list of GameServerSet resources
message GameServerSetList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated GameServerSet items = 2;
}

// GameServerSetSpec the specification for GameServerSet
message GameServerSetSpec {
  // Replicas are the number of GameServers that should be in this set
  optional int32 replicas = 1;

  // [Stage: Alpha]
  // [FeatureFlag:FleetAllocationOverflow]
  // Labels and Annotations to apply to GameServers when the number of Allocated GameServers drops below
  // the desired replicas on the underlying `GameServerSet`
  // +optional
  optional AllocationOverflow allocationOverflow = 4;

  // Scheduling strategy. Defaults to "Packed".
  optional string scheduling = 2;

  // Template the GameServer template to apply for this GameServerSet
  optional GameServerTemplateSpec template = 3;
}

// GameServerSetStatus is the status of a GameServerSet
message GameServerSetStatus {
  // Replicas is the total number of current GameServer replicas
  optional int32 replicas = 1;

  // ReadyReplicas is the number of Ready GameServer replicas
  optional int32 readyReplicas = 2;

  // ReservedReplicas is the number of Reserved GameServer replicas
  optional int32 reservedReplicas = 3;

  // AllocatedReplicas is the number of Allocated GameServer replicas
  optional int32 allocatedReplicas = 4;

  // ShutdownReplicas is the number of Shutdown GameServers replicas
  optional int32 shutdownReplicas = 5;

  // [Stage:Alpha]
  // [FeatureFlag:PlayerTracking]
  // Players is the current total player capacity and count for this GameServerSet
  // +optional
  optional AggregatedPlayerStatus players = 6;

  // (Alpha, CountsAndLists feature flag) Counters provides aggregated Counter capacity and Counter
  // count for this GameServerSet.
  // +optional
  map<string, AggregatedCounterStatus> counters = 7;

  // (Alpha, CountsAndLists feature flag) Lists provides aggregated List capacity and List values
  // for this GameServerSet.
  // +optional
  map<string, AggregatedListStatus> lists = 8;
}

// GameServerSpec is the spec for a GameServer resource
message GameServerSpec {
  // Container specifies which Pod container is the game server. Only required if there is more than one
  // container defined
  optional string container = 1;

  // Ports are the array of ports that can be exposed via the game server
  repeated GameServerPort ports = 2;

  // Health configures health checking
  optional Health health = 3;

  // Scheduling strategy. Defaults to "Packed"
  optional string scheduling = 4;

  // SdkServer specifies parameters for the Agones SDK Server sidecar container
  optional SdkServer sdkServer = 5;

  // Template describes the Pod that will be created for the GameServer
  optional k8s.io.api.core.v1.PodTemplateSpec template = 6;

  // (Alpha, PlayerTracking feature flag) Players provides the configuration for player tracking features.
  // +optional
  optional PlayersSpec players = 7;

  // (Alpha, CountsAndLists feature flag) Counters and Lists provides the configuration for generic tracking features.
  // +optional
  map<string, CounterStatus> counters = 8;

  map<string, ListStatus> lists = 9;

  // Eviction specifies the eviction tolerance of the GameServer. Defaults to "Never".
  // +optional
  optional Eviction eviction = 10;
}

// GameServerStatus is the status for a GameServer resource
message GameServerStatus {
  // GameServerState is the current state of a GameServer, e.g. Creating, Starting, Ready, etc
  optional string state = 1;

  repeated GameServerStatusPort ports = 2;

  optional string address = 3;

  optional string nodeName = 4;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time reservedUntil = 5;

  // [Stage:Alpha]
  // [FeatureFlag:PlayerTracking]
  // +optional
  optional PlayerStatus players = 6;

  // (Alpha, CountsAndLists feature flag) Counters and Lists provides the configuration for generic tracking features.
  // +optional
  map<string, CounterStatus> counters = 7;

  // +optional
  map<string, ListStatus> lists = 8;

  // Eviction specifies the eviction tolerance of the GameServer.
  // +optional
  optional Eviction eviction = 9;
}

// GameServerStatusPort shows the port that was allocated to a
// GameServer.
message GameServerStatusPort {
  optional string name = 1;

  optional int32 port = 2;
}

// GameServerTemplateSpec is a template for GameServers
message GameServerTemplateSpec {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional GameServerSpec spec = 2;
}

// Health configures health checking on the GameServer
message Health {
  // Disabled is whether health checking is disabled or not
  optional bool disabled = 1;

  // PeriodSeconds is the number of seconds each health ping has to occur in
  optional int32 periodSeconds = 2;

  // FailureThreshold how many failures in a row constitutes unhealthy
  optional int32 failureThreshold = 3;

  // InitialDelaySeconds initial delay before checking health
  optional int32 initialDelaySeconds = 4;
}

// ListStatus stores the current list values
message ListStatus {
  optional int64 capacity = 1;

  repeated string values = 2;
}

// PlayerStatus stores the current player capacity values
message PlayerStatus {
  optional int64 count = 1;

  optional int64 capacity = 2;

  repeated string ids = 3;
}

// PlayersSpec tracks the initial player capacity
message PlayersSpec {
  optional int64 initialCapacity = 1;
}

// SdkServer specifies parameters for the Agones SDK Server sidecar container
message SdkServer {
  // LogLevel for SDK server (sidecar) logs. Defaults to "Info"
  optional string logLevel = 1;

  // GRPCPort is the port on which the SDK Server binds the gRPC server to accept incoming connections
  optional int32 grpcPort = 2;

  // HTTPPort is the port on which the SDK Server binds the HTTP gRPC gateway server to accept incoming connections
  optional int32 httpPort = 3;
}

